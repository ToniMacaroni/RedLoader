#define NEW_INTEROP

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Net.Http;
using System.Reflection;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using RedLoader.Unity.Common;
using RedLoader.Unity.IL2CPP.Hook;
using Cpp2IL.Core;
using Cpp2IL.Core.Api;
using Cpp2IL.Core.InstructionSets;
using Cpp2IL.Core.OutputFormats;
using Cpp2IL.Core.ProcessingLayers;
using HarmonyLib;
using Il2CppInterop.Common;
using Il2CppInterop.Generator;
using Il2CppInterop.Generator.Runners;
using Il2CppInterop.HarmonySupport;
using Il2CppInterop.Runtime.Startup;
using LibCpp2IL;
using Microsoft.Extensions.Logging;
using Mono.Cecil;
using MonoMod.Utils;
using RedLoader;
using RedLoader.Utils;
using LogLevel = Microsoft.Extensions.Logging.LogLevel;
using MSLoggerFactory = Microsoft.Extensions.Logging.LoggerFactory;

namespace RedLoader.Unity.IL2CPP;

internal static partial class Il2CppInteropManager
{
    static Il2CppInteropManager()
    {
        InstructionSetRegistry.RegisterInstructionSet<X86InstructionSet>(DefaultInstructionSets.X86_32);
        InstructionSetRegistry.RegisterInstructionSet<X86InstructionSet>(DefaultInstructionSets.X86_64);
        LibCpp2IlBinaryRegistry.RegisterBuiltInBinarySupport();
    }

    private static readonly ConfigCategory InteropManagerCategory = new("il2cppinteropmanager", "Il2CppInteropManager");

    private static readonly ConfigEntry<bool> UpdateInteropAssemblies =
        InteropManagerCategory.CreateEntry("updateinteropassemblies", true,
                               "UpdateInteropAssemblies",
                               new StringBuilder()
                                   .AppendLine("Whether to run Il2CppInterop automatically to generate Il2Cpp support assemblies when they are outdated.")
                                   .AppendLine("If disabled assemblies in `BepInEx/interop` won't be updated between game or BepInEx updates!")
                                   .ToString());

    private static readonly string UnityBaseLibrariesSource = "https://unity.bepinex.dev/libraries/{VERSION}.zip";

    private static readonly string ConfigUnhollowerDeobfuscationRegex = string.Empty;

    private static readonly bool ScanMethodRefs = true;

    private static readonly ConfigEntry<bool> DumpDummyAssemblies = InteropManagerCategory.CreateEntry(
     "dumpdummyassemblies", false, "DumpDummyAssemblies",
     "If enabled, BepInEx will save dummy assemblies generated by an Cpp2IL dumper into BepInEx/dummy.");

    private static readonly string IL2CPPInteropAssembliesPath = "{BepInEx}";

    private static readonly bool PreloadIL2CPPInteropAssemblies = true;

    private static readonly string GlobalMetadataPath = "{GameDataPath}/il2cpp_data/Metadata/global-metadata.dat";

    private static string il2cppInteropBasePath;

    private static bool initialized;

    public static string GameAssemblyPath => Environment.GetEnvironmentVariable("BEPINEX_GAME_ASSEMBLY_PATH") ??
                                             Path.Combine(LoaderEnvironment.GameRootDirectory,
                                                          "GameAssembly." + PlatformHelper.LibrarySuffix);

    private static string HashPath => Path.Combine(IL2CPPInteropAssemblyPath, "assembly-hash.txt");

    private static string IL2CPPBasePath {
        get {
            if (il2cppInteropBasePath != null)
                return il2cppInteropBasePath;
            var path = Utility.GetCommandLineArgValue("--unhollowed-path") ?? IL2CPPInteropAssembliesPath;
            il2cppInteropBasePath = path.Replace("{BepInEx}", LoaderEnvironment.LoaderDirectory)
                                     .Replace("{ProcessName}", LoaderEnvironment.GameExecutableName);
            return il2cppInteropBasePath;
        }
    }

    private static string UnityBaseLibsDirectory => Path.Combine(IL2CPPBasePath, "unity-libs");

    internal static string IL2CPPInteropAssemblyPath => Path.Combine(IL2CPPBasePath, "Game");

    private static string RenameMapPath => Path.Combine(LoaderEnvironment.LoaderDirectory, "DeobfuscationMap.csv.gz");

    // private static ILoggerFactory LoggerFactory { get; } = MSLoggerFactory.Create(b =>
    // {
    //     b.AddProvider(new BepInExLoggerProvider())
    //      .SetMinimumLevel(LogLevel.Trace); // Each BepInEx log listener has its own filtering
    // });

    private static string ComputeHash()
    {
        using var md5 = MD5.Create();

        static void HashFile(ICryptoTransform hash, string file)
        {
            const int defaultCopyBufferSize = 81920;
            using var fs = File.OpenRead(file);
            var buffer = new byte[defaultCopyBufferSize];
            int read;
            while ((read = fs.Read(buffer)) > 0)
                hash.TransformBlock(buffer, 0, read, buffer, 0);
        }

        static void HashString(ICryptoTransform hash, string str)
        {
            var buffer = Encoding.UTF8.GetBytes(str);
            hash.TransformBlock(buffer, 0, buffer.Length, buffer, 0);
        }

        HashFile(md5, GameAssemblyPath);

        if (Directory.Exists(UnityBaseLibsDirectory))
            foreach (var file in Directory.EnumerateFiles(UnityBaseLibsDirectory, "*.dll",
                                                          SearchOption.TopDirectoryOnly))
            {
                HashString(md5, Path.GetFileName(file));
                HashFile(md5, file);
            }

        if (File.Exists(RenameMapPath))
        {
            HashFile(md5, RenameMapPath);
        }

        // Hash some common dependencies as they can affect output
        HashString(md5, typeof(InteropAssemblyGenerator).Assembly.GetName().Version.ToString());
        HashString(md5, typeof(Cpp2IlApi).Assembly.GetName().Version.ToString());

        md5.TransformFinalBlock(new byte[0], 0, 0);

        return Utility.ByteArrayToString(md5.Hash);
    }

    private static bool CheckIfGenerationRequired()
    {
        static bool NeedGenerationOrSkip()
        {
            if (!UpdateInteropAssemblies.Value)
            {
                var hash = ComputeHash();
                // Logger.LogWarning($"Interop assemblies are possibly out of date. To disable this message, create file {HashPath} with the following contents: {hash}");
                RLog.Warning($"Interop assemblies are possibly out of date. To disable this message, create file {HashPath} with the following contents: {hash}");
                return false;
            }

            return true;
        }

        if (!Directory.Exists(IL2CPPInteropAssemblyPath))
            return true;

        if (!File.Exists(HashPath))
            return NeedGenerationOrSkip();

        if (ComputeHash() != File.ReadAllText(HashPath) && NeedGenerationOrSkip())
        {
            // Logger.LogInfo("Detected outdated interop assemblies, will regenerate them now");
            RLog.Msg("Detected outdated interop assemblies, will regenerate them now");
            return true;
        }

        return false;
    }

    private static Assembly ResolveInteropAssemblies(object sender, ResolveEventArgs args)
    {
        var assemblyName = new AssemblyName(args.Name);
        return Utility.TryResolveDllAssembly(assemblyName, IL2CPPInteropAssemblyPath, out var foundAssembly)
                   ? foundAssembly
                   : null;
    }

    public static void Initialize()
    {
        if (initialized)
            throw new InvalidOperationException("Already initialized");
        initialized = true;

        Environment.SetEnvironmentVariable("IL2CPP_INTEROP_DATABASES_LOCATION", IL2CPPInteropAssemblyPath);
        AppDomain.CurrentDomain.AssemblyResolve += ResolveInteropAssemblies;

        GenerateInteropAssemblies();
        // var interopLogger = LoggerFactory.CreateLogger("Il2CppInterop");

        var unityVersion = UnityInfo.Version;
        Il2CppInteropRuntime.Create(new RuntimeConfiguration
                            {
                                UnityVersion = new Version(unityVersion.Major, unityVersion.Minor, unityVersion.Build),
                                DetourProvider = new Il2CppInteropDetourProvider()
                            })
                            .AddLogger(new HarmonyExceptionLogger())
                            .AddHarmonySupport()
                            .Start();
    }

    private static void GenerateInteropAssemblies()
    {
        if (!CheckIfGenerationRequired())
            return;

        try
        {
            Directory.CreateDirectory(IL2CPPInteropAssemblyPath);
            Directory.EnumerateFiles(IL2CPPInteropAssemblyPath, "*.dll").Do(File.Delete);

            AppDomain.CurrentDomain.AddCecilPlatformAssemblies(UnityBaseLibsDirectory);
            DownloadUnityAssemblies();
            var asmResolverAssemblies = RunCpp2Il();
#if !NEW_INTEROP
            var cecilAssemblies = new AsmToCecilConverter(asmResolverAssemblies).ConvertAll();
#endif

            // if (DumpDummyAssemblies.Value)
            // {
            //     var dummyPath = Path.Combine(Paths.BepInExRootPath, "dummy");
            //     Directory.CreateDirectory(dummyPath);
            //     foreach (var assemblyDefinition in cecilAssemblies)
            //         assemblyDefinition.Write(Path.Combine(dummyPath, $"{assemblyDefinition.Name.Name}.dll"));
            // }

#if NEW_INTEROP
            RunIl2CppInteropGenerator(asmResolverAssemblies);
#else
            RunIl2CppInteropGenerator(cecilAssemblies);
#endif

            File.WriteAllText(HashPath, ComputeHash());
        }
        catch (Exception e)
        {
            // Logger.LogError($"Failed to generate Il2Cpp interop assemblies: {e}");
            RLog.Error($"Failed to generate Il2Cpp interop assemblies: {e}");
        }
    }

    private static void DownloadUnityAssemblies() {
        var unityVersion = UnityInfo.Version;
        var version = $"{unityVersion.Major}.{unityVersion.Minor}.{unityVersion.Build}";
        var source = UnityBaseLibrariesSource.Replace("{VERSION}", version);
        if (string.IsNullOrEmpty(source)) return;

        var uri = new Uri(source);
        string file = Path.GetFileName(uri.AbsolutePath);

        var baseFolder = Directory.CreateDirectory(UnityBaseLibsDirectory);
        baseFolder.EnumerateFiles("*.dll").Do(a=>a.Delete());
        var target = baseFolder.GetFiles(file).FirstOrDefault();
        if (target != null) {
            // Logger.LogMessage($"Reading unity base libraries from file {source}");
            RLog.Msg($"Reading unity base libraries from file {source}");
            using var fStream = target.OpenRead();
            using var zipArchive = new ZipArchive(fStream, ZipArchiveMode.Read);
            zipArchive.ExtractToDirectory(UnityBaseLibsDirectory);
        } else {
            // Logger.LogMessage($"Downloading unity base libraries {source}");
            RLog.Msg($"Downloading unity base libraries {source}");
            using var httpClient = new HttpClient();
            using var zipStream = httpClient.GetStreamAsync(source).GetAwaiter().GetResult();
            // Logger.LogMessage("Extracting downloaded unity base libraries");
            RLog.Msg("Extracting downloaded unity base libraries");
            using var zipArchive = new ZipArchive(zipStream, ZipArchiveMode.Read);
            zipArchive.ExtractToDirectory(UnityBaseLibsDirectory);
        }
    }

    private static List<AsmResolver.DotNet.AssemblyDefinition> RunCpp2Il()
    {
        var metadataPath = Path.Combine(LoaderEnvironment.GameRootDirectory,
                                        GlobalMetadataPath
                                                          .Replace("{BepInEx}", LoaderEnvironment.LoaderDirectory)
                                                          .Replace("{ProcessName}", LoaderEnvironment.GameExecutableName)
                                                          .Replace("{GameDataPath}", LoaderEnvironment.UnityGameDataDirectory));
        
        // Logger.LogMessage("Running Cpp2IL to generate dummy assemblies from " + metadataPath);
        RLog.Msg("Running Cpp2IL to generate dummy assemblies from " + metadataPath);

        var stopwatch = new Stopwatch();
        stopwatch.Start();

        // var cpp2IlLogger = BepInEx.Logging.Logger.CreateLogSource("Cpp2IL");

        Cpp2IL.Core.Logging.Logger.VerboseLog += (message, s) =>
            // cpp2IlLogger.LogDebug($"[{s}] {message.Trim()}");
            RLog.Debug($"[{s}] {message.Trim()}");
        Cpp2IL.Core.Logging.Logger.InfoLog += (message, s) =>
            // cpp2IlLogger.LogInfo($"[{s}] {message.Trim()}");
            RLog.Msg($"[{s}] {message.Trim()}");
        Cpp2IL.Core.Logging.Logger.WarningLog += (message, s) =>
            // cpp2IlLogger.LogWarning($"[{s}] {message.Trim()}");
            RLog.Warning($"[{s}] {message.Trim()}");
        Cpp2IL.Core.Logging.Logger.ErrorLog += (message, s) =>
            // cpp2IlLogger.LogError($"[{s}] {message.Trim()}");
            RLog.Error($"[{s}] {message.Trim()}");

        var unityVersion = UnityInfo.Version;
        Cpp2IlApi.InitializeLibCpp2Il(GameAssemblyPath, metadataPath, unityVersion, false);

        List<Cpp2IlProcessingLayer> processingLayers = new() { new AttributeInjectorProcessingLayer(), };

        foreach (var cpp2IlProcessingLayer in processingLayers)
        {
            cpp2IlProcessingLayer.PreProcess(Cpp2IlApi.CurrentAppContext, processingLayers);
        }

        foreach (var cpp2IlProcessingLayer in processingLayers)
        {
            cpp2IlProcessingLayer.Process(Cpp2IlApi.CurrentAppContext);
        }

        var assemblies = new AsmResolverDllOutputFormatDefault().BuildAssemblies(Cpp2IlApi.CurrentAppContext);

        LibCpp2IlMain.Reset();
        Cpp2IlApi.CurrentAppContext = null;

        stopwatch.Stop();
        // Logger.LogInfo($"Cpp2IL finished in {stopwatch.Elapsed}");
        RLog.Msg($"Cpp2IL finished in {stopwatch.Elapsed}");

        return assemblies;
    }

#if NEW_INTEROP
    private static void RunIl2CppInteropGenerator(List<AsmResolver.DotNet.AssemblyDefinition> sourceAssemblies)
#else
    private static void RunIl2CppInteropGenerator(List<AssemblyDefinition> sourceAssemblies)
#endif
    {
        var opts = new GeneratorOptions
        {
            GameAssemblyPath = ScanMethodRefs ? GameAssemblyPath : null,
            Source = sourceAssemblies,
            OutputDir = IL2CPPInteropAssemblyPath,
            UnityBaseLibsDir = Directory.Exists(UnityBaseLibsDirectory) ? UnityBaseLibsDirectory : null,
            ObfuscatedNamesRegex = !string.IsNullOrEmpty(ConfigUnhollowerDeobfuscationRegex)
                                       ? new Regex(ConfigUnhollowerDeobfuscationRegex)
                                       : null,
        };

        if (File.Exists(RenameMapPath))
        {
            // Logger.LogInfo("Parsing deobfuscation rename mappings");
            RLog.Msg("Parsing deobfuscation rename mappings");
            opts.ReadRenameMap(RenameMapPath);
        }

        // Logger.LogInfo("Generating interop assemblies");
        RLog.Msg("Generating interop assemblies");

        // var logger = LoggerFactory.CreateLogger("Il2CppInteropGen");

        Il2CppInteropGenerator.Create(opts)
                              .AddLogger(new InteropLogger())
                              .AddInteropAssemblyGenerator()
                              .Run();

#if !NEW_INTEROP
        sourceAssemblies.Do(x => x.Dispose());
#endif
    }

    internal static void PreloadInteropAssemblies()
    {
        if (!PreloadIL2CPPInteropAssemblies)
            return;

        var sw = Stopwatch.StartNew();

        var files = Directory.EnumerateFiles(IL2CPPInteropAssemblyPath);
        var loaded = 0;
        Parallel.ForEach(files, file =>
        {
            if (!file.EndsWith(".dll", StringComparison.OrdinalIgnoreCase)) return;
            if (file.Equals("netstandard.dll", StringComparison.OrdinalIgnoreCase)) return;
            if (file.Equals("Il2Cppnetstandard.dll", StringComparison.OrdinalIgnoreCase)) return;
            try
            {
                Assembly.LoadFrom(file);
                Interlocked.Increment(ref loaded);
            }
            catch (Exception e)
            {
                // Logger.LogWarning($"Failed to preload {file} - {e}");
                RLog.Warning($"Failed to preload {file} - {e}");
            }
        });

        // Logger.LogDebug($"Preloaded {loaded} interop assemblies in {sw.ElapsedMilliseconds}ms");
        RLog.Debug($"Preloaded {loaded} interop assemblies in {sw.ElapsedMilliseconds}ms");
    }
}

public class HarmonyExceptionLogger : ILogger
{
    private const string HarmonyMessage = "During invoking native->managed trampoline";
            
    public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func<TState, Exception, string> formatter)
    {
        var msg = formatter(state, exception);
            
        if (exception != null && msg.Equals(HarmonyMessage))
        {
            RLog.MsgDirect(System.Drawing.Color.Fuchsia, "====== HARMONY EXCEPTION ======");
            RLog.MsgDirect(System.Drawing.Color.IndianRed, exception.ToString());
        }
    }

    public bool IsEnabled(LogLevel logLevel)
    {
        return logLevel == LogLevel.Error;
    }

    public IDisposable BeginScope<TState>(TState state)
    {
        throw new NotImplementedException();
    }
}

internal class InteropLogger : ILogger
{
    public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func<TState, Exception, string> formatter)
    {
        if (logLevel is LogLevel.Debug or LogLevel.Trace)
        {
            // MelonDebug.Msg(formatter(state, exception));
            RLog.Msg(formatter(state, exception));
            return;
        }
            
        // Core.Logger.Msg(formatter(state, exception));
        RLog.Msg(formatter(state, exception));
    }

    public bool IsEnabled(LogLevel logLevel)
    {
        #if DEBUG
        return true;
        #else
        return logLevel != LogLevel.Debug && logLevel != LogLevel.Trace;
        #endif
        // return logLevel switch
        // {
        //     LogLevel.Debug or LogLevel.Trace => MelonDebug.IsEnabled(),
        //     _                                => true
        // };
    }

    public IDisposable BeginScope<TState>(TState state)
    {
        throw new NotImplementedException();
    }
}
